A. Будильники
Ограничение времени	2 секунды
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Работа в большинстве IT-компаний имеет много преимуществ: нет дресс-кода, можно иногда поработать удалённо, классные и умные коллеги и, конечно же, свободный график! Однако свободный график и возможность работать удалённо требуют большой силы воли.
Программист Алексей любит работать по ночам и не любит приходить на работу поздно. Чтобы точно проснуться с утра, Алексей каждый вечер заводит
N
 будильников на своём телефоне. Каждый будильник устроен таким образом, что он звонит каждые
X
 минут с того момента времени, на который его завели. Например, если будильник был заведён на момент времени
t
i
, то он будет звонить в моменты времени
t
i
,
t
i
+
X
,
t
i
+
2
⋅
X
 и так далее. При этом если какие-то два будильника начинают звонить в один момент времени, то отображается только один из них.
Известно, что прежде чем проснуться, Алексей каждое утро слушает ровно
K
 будильников, после чего просыпается. Определите момент времени, когда Алексей проснётся.

Формат ввода
Первая строка содержит три целых числа
N
,
X
 и
K
 (
1
≤
N
≤
1
0
5
,
1
≤
X
,
K
≤
1
0
9
) — количество будильников, периодичность звонков и количество будильников, которое нужно отключить, чтобы Алексей проснулся.
Вторая строка содержит
N
 целых чисел
t
1
,
t
2
,
…
,
t
N
 (
1
≤
t
i
≤
1
0
9
) — моменты времени на которые были заведены будильники.

Формат вывода
Выведите одно число — момент времени, когда Алексей проснётся.
Пример 1
Ввод	Вывод
6 5 10
1 2 3 4 5 6
10
Пример 2
Ввод	Вывод
5 7 12
5 22 17 13 8
27
Примечания
Во втором примере заведено 5 будильников с периодичностью звонков 7. Например, первый будильник будет звонить в моменты времени 5, 12, 19, 26, 33, и т. д. Если рассмотреть все будильники одновременно, то они будут звонить в следующие моменты времени: 5, 8, 12, 13, 15, 17, 19, 20, 22 (2-й и 5-й будильники одновременно), 24, 26, 27, 29,
…
 На 12-й по счёту звонок Алексей должен проснуться, чему соответствует момент времени 27.


 B. Спортивный турнир
 Ограничение времени	2 секунды
 Ограничение памяти	256Mb
 Ввод	стандартный ввод или input.txt
 Вывод	стандартный вывод или output.txt
 Пока Маша была в отпуске, её коллеги организовали турнир по шахматам по олимпийской системе. За отдыхом Маша не обращала особого внимания на эту затею, так что она еле может вспомнить, кто с кем играл (про порядок игры даже речи не идёт). Внезапно Маше пришла в голову мысль, что неплохо бы привезти из отпуска сувенир победителю турнира. Маша не знает, кто победил в финальной игре, но сможет без труда вычислить, кто в нём играл, если только она правильно запомнила играющие пары. Помогите ей проверить, так ли это, и вывести возможных кандидатов в победители.
 Формат ввода
 В первой строке находится целое число
 k
 ,
 2
 ≤
 k
 ≤
 1
 6
 , — количество этапов турнира. В последующих
 n
 =
 2
 k
 −
 1
  строках — по две фамилии игроков (латинскими заглавными буквами) через пробел. Все фамилии уникальны, однофамильцев среди коллег нет.
 Формат вывода
 «NO SOLUTION» (без кавычек) — если Маша неправильно запомнила игры и по этой сетке нельзя получить турнир по олимпийской системе. Если турнирная сетка возможна, выведите две фамилии в одной строке — фамилии кандидатов на первое место (порядок не важен).
 Пример 1
 Ввод	Вывод
 3
 GORBOVSKII ABALKIN
 SIKORSKI KAMMERER
 SIKORSKI GORBOVSKII
 BYKOV IURKOVSKII
 PRIVALOV BYKOV
 GORBOVSKII IURKOVSKII
 IURKOVSKII KIVRIN
 IURKOVSKII GORBOVSKII
 Пример 2
 Ввод	Вывод
 2
 IVANOV PETROV
 PETROV BOSHIROV
 BOSHIROV IVANOV
 NO SOLUTION



 C. Интересная игра
 Ограничение времени	2 секунды
 Ограничение памяти	256Mb
 Ввод	стандартный ввод или input.txt
 Вывод	стандартный вывод или output.txt
 Петя и Вася играют в интересную игру. Сначала Вася объявляет, сколько очков нужно набрать, чтобы игра закончилась. Затем Петя берет карточки, на которых написаны целые неотрицательные числа, и начинает выкладывать их на стол одну за другой. Если на карточке число, кратное шести, то Вася получает одно очко. Если на карточке число, кратное девяти, то одно очко получает Петя. Если на карточке число, кратное и шести, и девяти одновременно, то у каждого из участников вычитается по одному очку (при этом, если у кого-то из участников 0 очков, то он не получает штрафа). Если на карточке число, не кратное ни шести, ни девяти, то очков не получает никто.
 Как только кто-то из участников наберет количество очков, которое назвал в начале игры Вася, игра прекращается и этот игрок становится победителем. Если никто из участников не набрал нужного количества очков, а все карточки закончились, то победителем считается тот, у кого больше очков. Если все карточки закончились, а очков поровну, то объявляется ничья.
 Петя и Вася иногда очень спешат, поэтому хотят не играть в игру полностью, а сразу узнать, кто выиграл бы при известных начальных данных. Они попросили вас написать программу, которая поможет ответить на этот вопрос.

 Формат ввода
 В первой строке через пробел даны два целых положительных числа: количество очков
 K
 , которое объявляет в начале игры Вася, и количество карточек
 N
 , которые есть у Пети (
 1
 ≤
 K
 ≤
 1
 0
 0
 0
 ,
 1
 ≤
 N
 ≤
 1
 0
 6
 ). В следующей строке даны
 N
  целых неотрицательных чисел, разделенных пробелом, каждое из которых не превосходит 1000.
 Формат вывода
 В единственной строке выведите Petya, если в игре побеждает Петя, Vasya, если в игре побеждает Вася, или Draw, если победителя выявить не удалось.
 Пример 1
 Ввод	Вывод
 2 10
 6 9 54 6 54 9 9 1 2 3
 Petya
 Пример 2
 Ввод	Вывод
 2 6
 54 6 6 9 9 9
 Vasya


 D. Анализатор исключений
 Ограничение времени	2 секунды
 Ограничение памяти	256Mb
 Ввод	стандартный ввод или input.txt
 Вывод	стандартный вывод или output.txt
 Опишем синтаксис языка программирования
 E
 X
 :
 f
 u
 n
 c
 f
 (
 )
 {
 …
 }
  — объявление функции
 f
  (в скобочках — тело).
 m
 a
 y
 b
 e
 t
 h
 r
 o
 w
 E
 x
 c
 1
  — команда, которая может выбросить исключение вида
 E
 x
 c
 1
 , а может и не выбросить.
 t
 r
 y
 {
 …
 }
 s
 u
 p
 p
 r
 e
 s
 s
 E
 x
 c
 1
  — если внутри этого блока происходит исключение вида
 E
 x
 c
 1
 , то оно подавляется.
 f
 (
 )
  — вызов функции
 f
 .
 В языке
 E
 X
  все инструкции, кроме объявлений функций, могут находиться только в теле какой-либо функции. Функции нельзя объявлять внутри других функций. Функцию можно вызывать до её определения, а также в её собственном теле. Имена функций и исключений в языке
 E
 X
  должны подходить под регулярное выражение
 [
 a
 −
 z
 A
 −
 Z
 0
 −
 9
 _
 ]
 +
 , быть уникальными и не совпадать с ключевыми словами [
 f
 u
 n
 c
 ,
 t
 r
 y
 ,
 s
 u
 p
 p
 r
 e
 s
 s
 ,
 m
 a
 y
 b
 e
 t
 h
 r
 o
 w
 ]. Текст программы может содержать произвольное количество пробелов и пустых срок.
 На вход подаётся программа на языке
 E
 X
 . Также на вход программе подаётся
 q
  запросов. Каждый запрос — это одно число
 l
  — номер строчки в программе. Необходимо для каждого запроса вывести все исключения, которые могут вылететь в выделенной строчке программы.

 Формат ввода
 В первой строке входных данных находится единственное число  —
 q
  (
 1
 ≤
 q
 ≤
 1
 0
 3
 ), количество запросов. Далее следует
 q
  чисел по одному в строке — номера строк в запросах. Гарантируется, что все номера строк корректны. В следующей строке входных данных находится единственное число  —
 n
 , количество объявлений функций в коде. В последующих строках находится текст программы на языке
 E
 X
 .
 Гарантируется, что каждая строка программы подходит под одно из описаний ниже:

 Пустая строка.
 f
 u
 n
 c
 f
 (
 )
 {
  — объявление функции
 f
 .
 }
  — конец тела функции.
 m
 a
 y
 b
 e
 t
 h
 r
 o
 w
 E
 x
 c
 1
 .
 t
 r
 y
 {
  — начало блока подавления исключений.
 }
 s
 u
 p
 r
 e
 s
 s
  — конец блока подавления исключений.
 f
 (
 )
  — вызов функции
 f
 .
 Количество вызовов функций в коде не превосходит
 1
 0
 3
 .
 Количество видов исключений в коде не превосходит
 1
 0
 3
 .
 Количество символов в коде не превосходит
 1
 0
 6
 .

 Формат вывода
 Для каждого запроса выведите строку, содержащую имена всех исключений, которые являются ответами на запрос, разделённые пробелами.
 Пример
 Ввод	Вывод
 5
 14
 1
 7
 14
 4
 2
 func func1() {
 maybethrow exc1
 try {
 maybethrow exc2
 maybethrow exc3

 } suppress exc1, exc2, exc3
 maybethrow exc4

 }

 func main() {
 try {
 func1()
 } suppress exc1
 }
 exc1 exc4


 exc1 exc4
 exc2


 E. Раскодирование
 Ограничение времени	2 секунды
 Ограничение памяти	256Mb
 Ввод	стандартный ввод или input.txt
 Вывод	стандартный вывод или output.txt
 В интернете появился новый сервис. К сожалению, у него нет документации. Опытным путем от сервера была получена строка
 s
 . Однако некоторые символы в этой строке закодированы и чтобы получить настоящий ответ, нужно эту строку раскодировать несколько раз. Поскольку документация на сервис отсутствует, для дальнейших экспериментов нужно определить какое максимальное число раз можно нетривиальным образом раскодировать эту строку. Процедура раскодирования следующая: нужно найти все подстроки вида «&XY;» (без кавычек), где
 X
  и
 Y
 — большие или маленькие шестнадцатеричные цифры и заменить их одновременно на символ с ASCII-кодом
 1
 6
 X
 +
 Y
  (у каждой подстроки свой). Раскодирование называется тривиальным, если подстрок такого вида нет.
 Формат ввода
 На входе дана строка
 s
  длины
 1
 ≤
 |
 s
 |
 ≤
 3
 0
 0
 0
 0
 0
 , состоящая из символов с кодами от 33 до 126 включительно.
 Формат вывода
 В единственной строке выведите максимальное число последовательных нетривиальных раскодирований исходной строки.
 Пример 1
 Ввод	Вывод
 &26;
 1
 Пример 2
 Ввод	Вывод
 &&32;&36;;&fF;
 2
 Пример 3
 Ввод	Вывод
 &&30;&30;;&3b&3B;
 2
 Пример 4
 Ввод	Вывод
 &Ff&3b;
 2
 Пример 5
 Ввод	Вывод
 &he;llo
 0
 Примечания
 В процессе раскодирования могут появляться символы с кодами меньше 33 или больше 126. Символ "&" имеет ASCII код 0x26=38, а символ ";" имеет ASCII код 0x3b=59.


 F. Поиск ломающего коммита
 Ограничение времени	2 секунды
 Ограничение памяти	256Mb
 Ввод	стандартный ввод
 Вывод	стандартный вывод
 В Поиске Яндекса реализована так называемая политика "зелёного транка": любой код, попадающий в репозиторий, с некоторыми оговорками гарантированно не ломает сборку и тесты.
 Тесты, впрочем, бывают крайне сложными, и запускать их все на каждый коммит оказывается нецелесообразно. Так что для особенно сложных случаев реализована следующая процедура: тесты запускаются с некоторой регулярностью, а проверяется сразу набор коммитов. Так что в течение некоторого времени в транк могло попасть
 n
  непроверенных коммитов, после которых оказалось, что как минимум один из них содержал ошибку.
 В такой ситуации тестирующая система должна обнаружить номер
 m
  первого коммита, сломавшего тесты. Этот номер обладает следующим свойством: все коммиты с номерами, меньшими
 m
 , успешно проходят тесты, а коммиты с номерами, большими либо равными
 m
 , тесты не проходят. В данной задаче гарантируется, что коммит с указанными свойствами обязательно существует и является единственным.
 В целях экономии ресурсов тестирующая система может проверять только три коммита одновременно. Вам требуется написать программу, которая будет определять номер
 m
 .
 Эта задача немного необычна — в ней вам предстоит реализовать интерактивное взаимодействие с тестирующей системой. Это означает, что вы можете делать запросы и получать ответы в online-режиме. Обратите внимание, что ввод/вывод в этой задаче — стандартный (то есть с экрана на экран). После вывода очередного запроса обязательно используйте функции очистки потока, чтобы часть вашего вывода не осталась в каком-нибудь буфере. Например, на С++ надо использовать функцию fflush(stdout), на Java вызов System.out.flush(), на Pascal flush(output) и stdout.flush() для языка Python.
 Вы можете делать запросы к тестирующей системе. Каждый запрос — это вывод ровно трёх целых чисел, каждое из которых принадлежит диапазону от
 1
  до
 n
 . Для каждого выведенного числа тестирующая система возвращает один из двух результатов:

 строка «1» (без кавычек), если коммит с соответствующим номером успешно проходит все тесты;
 строка «0» (без кавычек), если коммит с соответствующим номером не проходит тесты.
 Если ваша программа в точности знает номер
 m
 , она должна вывести строку вида «! m», после чего завершить свою работу.
 Вашей программе разрешается сделать не более
 1
 3
  запросов.

 Формат ввода
 Для чтения ответов на запросы программа должна использовать стандартный ввод.
 В первой строке входных данных будет содержаться целое положительное число
 n
  (
 1
 ≤
 n
 ≤
 1
 0
 6
 ) — количество совершённых коммитов.
 В следующих строках на вход вашей программе будут подаваться строки, содержащие тройки символов «1» или «0».
 i
 -я из этих строк является ответом системы на ваш
 i
 -й запрос. После того, как ваша программа угадала номер коммита, выведите «! m» (без кавычек), где
 m
  — это ответ, и завершите работу своей программы.
 Тестирующая система даст вашей программе прочитать ответ на запрос из входных данных только после того, как ваша программа вывела соответствующий запрос системе и выполнила операцию flush.

 Формат вывода
 Для осуществления запросов программа должна использовать стандартный вывод.
 Ваша программа должна выводить запросы — тройки целых чисел
 x
 i
 ,
 y
 i
 ,
 z
 i
  (
 1
 ≤
 x
 i
 ,
 y
 i
 ,
 z
 i
 ≤
 n
 ) в одной строке (не забывайте выводить «перевод строки» после каждой тройки выведенных чисел). После вывода каждой строки программа должна выполнить операцию flush.
 Каждая из троек
 x
 i
 ,
 y
 i
 ,
 z
 i
  обозначает очередной запрос к системе. Ответ на запрос программа сможет прочесть из стандартного ввода. В случае, если ваша программа угадала число
 m
 , выведите строку вида «! m» (без кавычек), где
 m
  — ответ, после чего завершите работу программы.

 PIC